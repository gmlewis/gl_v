module gen

import os

fn head(body string) string {
	return 'module gl

// generated by the gl_v bindings generator
// do not edit by hand

$body

// generated by the gl_v bindings generator
// do not edit by hand\n'
}

struct Data {
	fns   []Fn
	enums []Enum
}

pub fn (fns []Fn) gen() string {
	return head(fns.map(it.gen()).join('\n'))
}

pub fn (enums []Enum) gen() string {
	raw := enums.map(it.gen()).join('\n')
	return head('const (\n$raw\n)')
}

pub struct WriteConfig {
	root string

	fns_file   string
	enums_file string
}

pub fn (data Data) write(conf WriteConfig) ? {
	make_sure_dir_exists(conf.root) ?
	os.write_file(os.join_path(conf.root, conf.fns_file), data.fns.gen()) ?
	os.write_file(os.join_path(conf.root, conf.enums_file), data.enums.gen()) ?
}

struct Fn {
	name  string
	types FnTypes
}

fn (fun Fn) gen() string {
	returns := if fun.types.returns != Type('') { ' $fun.types.returns.gen()' } else { '' }
	args := fun.types.args.map(it.gen()).join(', ')

	return 'fn C.${fun.name}($args)$returns'
}

struct FnTypes {
	returns Type
	args    []Var
}

struct Var {
	name string
	kind Type
}

fn (var Var) gen() string {
	name := unreserve_word(var.name)
	return '$name $var.kind.gen()'
}

struct PtrType {
	child Type
}

fn (ty PtrType) gen() string {
	if ty.child == Type('') {
		return 'voidptr'
	}
	return '&$ty.child.gen()'
}

struct ArrayType {
	len   int
	child Type
}

fn (ty ArrayType) gen() string {
	return '[$ty.len]$ty.child.gen()'
}

type Type = ArrayType | PtrType | string

fn (ty Type) gen() string {
	return match ty {
		string { ty }
		PtrType { ty.gen() }
		ArrayType { ty.gen() }
		// using else here caused a segfault
	}
}

struct Enum {
	name string
	val  string
}

fn (en Enum) gen() string {
	name := unreserve_word(translate_enum(en.name))
	return '\t$name = $en.val'
}
